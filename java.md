
# 1:hashmap：
* hashmap底层：数组+链表+红黑树（长度64，且有8个元素，则从链表变为红黑树，至于为什么是红黑树是因为AVL每次插入删除需要严格的旋转）
* hashmap和hashtable的区别：
	* hashtable线程安全，但是hashtable是Dictionary下的，但是Dictionary已经被废弃了，所以hashtable也不适用了,此外，hashtable是不能存储null，但是hashmap是可以的。
	* Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。
	* hashmap扩容机制：HashMap的容量，默认是16，且HashMap的加载因子，默认是0.75。
	* 当调用put操作时，HashMap计算键值K的哈希值，然后将其对应到HashMap的某一个桶(bucket)上；此时找到以这个桶为头结点的一个单链表，然后顺序遍历该单链表找到某个节点的Entry中的Key是等于给定的参数K；若找到，则将其的old V替换为参数指定的V；否则直接在链表尾部插入一个新的Entry节点。
# 2:ArrayList：
* ArrayList和LinkedList的区别：ArrayList的查找和访问元素的速度较快，但新增，删除的速度较慢，LinkedList的查找和访问元素的速度较慢，但是他的新增，删除的速度较快（链表删除插入O(1)查询O(n)）。
* Arraylist线程不安全，可以在add加synchronized关键字或着ThreadLocal。采用vector。
* ArrayList扩容:因为ArrayList底层是是通过数组来实现的，然后原理简单来说就是当容器达到上线，就会进行扩容，扩容为原本的长度的1.5倍。重点是：默认容量为10！！！
# 3:wait和sleep的区别
* 这两个就不是一个类，sleep是Thread类里的方法，而wait是Object（jvm层提供的关键字）。
* 最主要的是sleep方法没有释放锁资源，而wait方法释放了锁，使得其他线程可以使用同步代码块或者方法。
* sleep需要捕获异常，但是wait和notify和notifyall不需要捕获。
sleep是Thread类的静态方法。sleep的作用是让线程休眠制定的时间，在时间到达时恢复，也就是说sleep将在接到时间到达事件事恢复线程执行。wait是Object的方法，也就是说可以对任意一个对象调用wait方法，调用wait方法将会将调用者的线程挂起，直到其他线程调用同一个对象的notify方法才会重新激活调用者。
# 4:String，Stringbuffer和Stringbuilder的区别
* 主要的就是Stringbuffer是线程安全的，但是Stringbuilder是不安全的，但是我们为了性能，在不考虑并发或者高并发的情况下，我们尽量使用StringBuilder。
* String的值是不可变的被final修饰，这也就导致final类无法被继承重写，这就导致，我们每次对String操作，都会重新定义一个String。
# 5:浅拷贝和深拷贝：就是==为浅拷贝，clone为深拷贝
# 6:String s1=new String("hello, world")创建了几个对象
>一个或者两个，主要是看我们JVM内存中的常量池中有无"hello, world"如果有，那new关键字就会在堆中创建出一个新的对象，如果没有就会是两个，因为还会在常量池中创建一个"hello, world"
# 7:static关键字
* 修饰变量的话：被称为静态变量，该变量属于当前类所有，位于方法区，可以通过"类名".变量名访问，就不需要通过实例化在进行使用。
* 修饰方法，static 修饰的方法被称为静态方法，静态方法能够直接通过 类名.方法名 来使用，在静态方法内部不能使用非静态属性和方法
* static 可以修饰代码块，主要分为两种，一种直接定义在类中，使用 static{}，这种被称为静态代码块，一种是在类中定义静态内部类，使用 static class xxx 来进行定义。
* 静态内部类：访问外部类的静态变量，但是无法访问非静态变量，且static内部类具备所有外部类的特性。
# 8:Final关键字，final 是 Java 中的关键字，它表示的意思是 不可变的
* 修饰类，final 修饰的类不能被继承。这个就导致了abstract和final不能同时出现（这也就是为什么父类为什么不能被final修饰）
* 修饰变量，final 修饰的变量不能被改写，不能被改写的意思有两种，对于基本数据类型来说，final 修饰的变量，其值不能被改变，final 修饰的对象，对象的引用不能被改变，但是对象内部的属性可以被修改。final 修饰的变量在某种程度上起到了不可变的效果，所以，可以用来保护只读数据，尤其是在并发编程中，因为明确的不能再为 final 变量进行赋值，有利于减少额外的同步开销。
* 修饰方法，final 修饰的方法不能被重写。
# 9:synchronized和lock区别：
* synchronized是JVM层面的一个关键字，lock是一个类
* synchronized是以获取锁的线程执行完同步代码，释放锁，且当线程执行发生异常，JVM会让线程释放锁，此外lock必须在Finally中必须释放锁这里指的释放锁是.unlock，否则容易造成死锁。
* synchronized假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待，且是非公平锁，lock是一公平锁（公与非公略）
# 10:乐观锁和悲观锁：
* 悲观锁：每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。其实也就是，如果写操作比较多的情况下，要用被关锁。
* 乐观锁：每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。读操作比较多的话，就用乐观锁。
# 11:反射机制
>在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法，并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为反射机制。
就类似于ide中的名字后面的.一下会出现方法。
# 12:JVM内存模型
* 线程私有数据区：
	* 程序计数器:为了线程切换过程中能够使线程恢复到正常执行位置，每条线程都需要有一个独立的程序计数器来记录正在执行的字节码指令地址。程序计数器是线程私有的很小一块内存空间，简单理解为：记录当前线程所执行的字节码的行号指示器。

* 本地方法栈
	* 线程私有，虚拟机栈为虚拟机执行java方法服务，但是本地方法栈为虚拟机执行native方法服务。
* 虚拟机栈每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，而且每个方法从调用直至完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。其中，局部变量表主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和 对象句柄，它们可以是方法参数，也可以是方法的局部变量。
线程共享数据
* java堆唯一目的就是存放对象实例，几乎所有的对象实例和数组都在这里分配内存。也是GC工作的重点区域。新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，对象就会被移入老年代。新生代又可进一步细分为 eden、survivorSpace0 和 survivorSpace1。
* 方法区
	* 类信息，常量，静态变量，及时编译器后代码等工具，方法区通常和永久区(Perm)关联在一起，但永久代与方法区不是一个概念，只是有的虚拟机用永久代来实现方法区，这样就可以用永久代GC来管理方法区，省去专门内存管理的工作。根据Java虚拟机规范的规定，当方法区无法满足内存分配的需求时，将抛出 OutOfMemoryError 异常。
# 13:synchronized和volatile的区别
* volatile的本质就是是java虚拟机(JVM)当前变量在工作内存中的值是不确定的，需要从主内存中读取；synchronized则是锁定当前的变量，只有当前线程可以访问到该变量，其他的线程将会被阻塞。
* volatile只能实现变量的修改可见性，并不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。
* volatile只能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
* volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
