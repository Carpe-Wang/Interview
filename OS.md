# 1:进程和线程的区别：
```简单来说就是把进程比喻为一列火车，线程为火车车厢
线程在进程下行进。
一个进程包括很多线程。（一列火车有多个车厢）。
```

#### 不同进程间，数据比较难共享，但线程间的通信就简单很多了（车站换乘，换车厢）。
#### 进程比线程消耗更多的计算机资源。
#### 不同进程间，相互不影响，但是一个线程挂掉会导致一个进程挂掉（车厢断裂）。

# 2:进程间通信方法：
* 管道:如linux下的 `cat catalina.out | grep -C "10" "id"`。
* 信号：比较复杂，不想写了，不会细问。
* 消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。
* 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；
* 信号量：最常用的，最有用的它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。如:`linux下的 kill -9 #{id},control+C`。
 * 套接字(socket)：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。`如mysql的3306，通过网络请求到3306`。
# 3:线程同步方法：
* 互斥量（lock，synchronized）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。

* 事件（notify，wait）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。
# 4:进程调度算法：
 * 先来先服务：`非抢占式的调度算法`，按照请求的顺序进行调度。`有利于长作业，但不利于短作业`，可能造成了短作业等待时间过长。对`I/O密集型进程也不利，因为这种进程每次进行I/O操作之后又得重新排队`。
 * 短作业优先：`非抢占式的调度算法`，作业时常短的优先。
 * 最短剩余时间优先：最短作业优先的`抢占式`版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。
 * 时间片轮转:`将所有就绪进程按 FCFS 的原则排成一个队列`，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。
	* 这就引出另外的问题：效率和时间片的大小有很大关系。
# 5:死锁：
* 产生原因：
    * 互斥：至少有一个资源是属于非共享的，就是一次只能有一个进程来访问，比如，一个女神有很多人追，但是同时只能和一个在一起，分手之后，才能考虑和其他的追求者在一起，这里女神换成资源，追求者为进程。
    * 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；
    * 非抢占：进程不能被抢占，必须等到进程完成任务后自动释放。
    * 循环等待：多个进程之间，形成相互等待的环形。
* 防止死锁：
    * 死锁预防：只要打破产生死锁的四个原因之一就行	
    * 打破互斥条件：允许进程同时访问某些资源。女神可以谈多个了。
    * 打破占有并等待条件：可以实行资源预先分配策略。
    * 打破非抢占条件：允许进程强行从占有者哪里夺取某些资源。
    * 打破循环等待条件：实行资源有序分配策略。
* 死锁避免：
    * 死锁避免的基本思想是动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。资源分配图算法和银行家算法是两种经典的死锁避免的算法，其可以确保系统始终处于安全状态。其中，资源分配图算法应用场景为每种资源类型只有一个实例(申请边，分配边，需求边，不形成环才允许分配)，而银行家算法应用于每种资源类型可以有多个实例的场景。
* 死锁解除：
++死锁解除的常用两种方法为进程终止和资源抢占。这个时候我们需要考虑三个问题:++
    * 选择一个牺牲品 
    * 回滚：回滚到安全状态 
    * 饥饿
# 6:进程的状态：
* 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；
* 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；
* 阻塞状态： 进程等待某种条件，在条件满足之前无法执行；
# 7:线程的状态：
* new
* ready
* running
* blocked
* exit
具体参考笔记

# 8:公平锁和非公平锁
* 公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
    * 优点：所有的线程都可以得到资源，不会饿死在队列中。
    * 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。
* 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。
    * 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
    * 缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。
# 9:乐观锁悲观锁(注意区分，用go来介绍)
* 基本概念如下：

    * 乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。
    * 要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（java中的synchronized）。
 * 实现原理
    * 悲观锁：主要是通过共享锁或者排他锁，先把数据锁起来，在进行操作（其实就是lock和unlock）。大概流程为。  
        * <font color="#dd0000">*1:ab两条线程，控制两条事务，事务a对共享的数据加锁成功后事务，b也就被阻塞了*
        * 2:事务a提交，锁被释放，事务b对数据增加拍他锁，之后开始执行*：</font><br /> 
    * 乐观锁：CAS（比较和交换）
        * <font color="#dd0000"> CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。</font><br /> 
    * 代码实现：
```go
import (
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)

func IncreValue1() { //不加锁
	value1++
}

func IncreValue2() { //乐观锁
	atomic.AddInt32(&value2, 1)
}

func IncreValue3() { //悲观锁
	lock.Lock()
	value3++
	lock.Unlock()
}

var value1, value2, value3 int32
var lock sync.Mutex

func main() {
	//开启1000个线程，并执行自增操作
	for i := 0; i < 1000; i++ {
		go IncreValue1()
		go IncreValue2()
		go IncreValue3()
	}
	//打印结果
	time.Sleep(1000)
	fmt.Println("线程不安全：", value1) //线程不安全： 988
	fmt.Println("乐观锁：", value2)   //乐观锁： 1000
	fmt.Println("悲观锁：", value2)   //悲观锁：1000
}
```
# 10: 内存管理
* 为什么要有虚拟内存
> 物理主存空间有限，所以一般现代操作系统都会想办法把一部分内存块放到磁盘中，用到的时候再装入主存，但是对用户程序而言，是不需要注意实际的物理内存的。
<font color="#dd0000">简单说，虚拟内存是操作系统提供的⼀种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</font><br /> 

* 内存分段
> 程序是由若⼲个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就⽤分段（Segmentation）的形式把这些段分离出来。
<font color="#dd0000">分段机制下的虚拟地址由两部分组成，段号和段内偏移量。
虚拟地址和物理地址通过段表映射，段表主要包括段号、段的界限。</font><br /> 
![在这里插入图片描述](https://img-blog.csdnimg.cn/e2ed93e467ee477f86660ce4af086379.png)
* 内存分页
> 分⻚是把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩。这样⼀个连续并且尺⼨固定的内存空间，我们叫⻚（Page）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/0108486cf2104fe3893a3f2e3958cc18.png)

